/**
*Option.h* is a file generated by *launcher.sh* which only defines variables 
*ADAPTIVE* as a boolean to control the use of adaptive mesh refinement and 
Basilisk view module.
 **/
#include "options.h"
/**
parameters.h defines a set of functions used to read the simulation parameters
in an input file instead of defining it in the main *.c* file. It saves also the
 name of the output files generated by the bash.
 **/
#include "parameters.h"
/**
We include following solvers and interactions modules : Navier-Stokes solver, 
two-phase flow, surface tension, Van der Waals solid liquid interaction and 
reduced gravity.
 **/
#include "navier-stokes/centered.h"
#include "two-phase.h"
#include "tension.h"
#include "vanderwaals_no-pos.h"
#include "reduced.h"
#include "view.h"
/**
*contact_angle.h* computes three different contact angle of the droplet with the
least squared method:
-the left contact angle *theta_L* (with the interface on the left of the center of
 mass)
-the right contact angle *theta_R* (with the interface on the right of the center 
 of mass)
-the average contact angle theta (with the whole interface)
 **/
#include "contact_angle.h"
/**
Definition of $\pi$ and the radian/degree converter
 **/
#define M_PI 3.14159265358979323846
#define RADEG (M_PI/180.0)
int Nelement;//Unused ?

/**
These fp (file pointers) will points on each used files during the simulation :
-in      : the input file input.in
-stats   : statistics file stats.out
-interf  : interface points file interf.out
-lsqcout : output of the least square circle approximation of one frame
-results : metadata file which compiles multiple simulation results
 **/
FILE * fp_in      = NULL;
FILE * fp_stats   = NULL;
FILE * fp_interf  = NULL;
FILE * fp_lsqcout = NULL;
FILE * fp_results = NULL;
/**
The following variables are auxiliary ones which are meant to compute current
statistics or to save previous steps ones (_old)
 **/
scalar l[]; //Level field for the mirror movie output
scalar uxf[]; //auxiliary field for u.x*f in each cell
scalar xf[];  //auxiliary field for x*f in each cell
scalar yf[];  //auxiliary field for y*f in each cell
float theta_old = 0.;
float umax, umean, vmax, vmean, vol = 0.;
float umax_old, umean_old, vmax_old, vmean_old, vol_old = 0.;
float ca_mean, ca_L, ca_R = 0.;
float LSQC_x, LSQC_y, LSQC_R, LSQC_Rold = 0.;
float LSQC_xL, LSQC_yL, LSQC_RL, LSQC_RoldL = 0.;
float LSQC_xR, LSQC_yR, LSQC_RR, LSQC_RoldR = 0.;
float XinfL, XinfR, XinfL_old, XinfR_old = 0.;
float Xcm, Ycm, Ucm = 0;
float tn, tnm1 = 0.;
float VinfL, VinfR, LSQC_VR = 0.;
/**
This structure contains all parameters which can be changed using the launcher.
It is defined in parameters.h. Check it out if you want to have a indication on 
the role of each parameter.
 **/
struct Sim_Parameters  param;

/**
Adaptive mesh refinement can be disable with *launcher.sh*. The error is check
on the velocity and density fields $u$ and $f$. It also includes a call to refine
function in view to enforce high resolution on the thin liquid film.
 **/
#if ADAPT
event adapt (i++)
{
  boundary({u,f});
  adapt_wavelet ({u,f}, (double []) {1e-3,1e-3,1e-5},
		 minlevel=2, maxlevel = param.MAX_LEVEL);
    refine (level < param.MAX_LEVEL &&
	    (y - param.SIZE/(1 << level) <= 0 ||
	     y - param.HSTAR <= 0));
}
#endif
/**
The main function has been adapted to read an input parameter.
The program will run with default parameters if one write default as input.
 **/
int main ( int argc, char *argv[] )
{
  if (argc != 2) /* argc should be 2 for droplet and input.in */
    {
      printf("ERROR : input file must be provided");return 0;
    }
  /**
Reading parameters from input file, this function is defined in parameters.h. 
We then open the files meant to contain our outputs
  **/
  read_parameters (argv[1], &param);

  if (fp_stats)
    fclose (fp_stats);
  fp_stats = fopen (param.fn_stats, "w");
  if (fp_interf)
    fclose (fp_interf);
  fp_interf = fopen (param.fn_interf, "w");
  if (fp_lsqcout)
    fclose (fp_lsqcout);
  fp_lsqcout = fopen (param.fn_lsqcout, "w");
  if(fp_results)
    fclose(fp_results);
  fp_results = fopen(param.fn_results, "a");
  //Header for the stats file
  fprintf (fp_stats,
	   "%-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s\n",
	   "t","umax","umean","vmax","vmean","volume","theta",
	   "XC","YC","RC","VRC","XinfL","XinfR","VinfL","VinfR",
	   "Xcm", "Ycm","Ucm","thetaL","thetaR");
  /**
The angle given as input are converted in radian and the Basilisk simulation 
parameters are set thanks
  **/
  param.PANGLE    *= RADEG;
  param.THETA0    *= RADEG;
  param.THETA_EQ  *= RADEG;
  size (param.SIZE);
  f.sigma   = param.SIGMA;
  mu1       = param.MU;
  mu2       = mu1 * param.MUR;
  rho1      = param.RHO;
  rho2      = rho1 * param.RHOR;
  if (param.STOKES == 1)
    stokes = true;
  if (param.Gy != 0)
    G.y = param.G*-cos(param.PANGLE);
  G.x = param.G*sin(param.PANGLE);
  N = 1 << param.MAX_LEVEL;
  #if ADAPT
  N = 1 << param.LEVEL;
  #endif
  init_grid (N);

  /**
Dirichlet boundary conditions are put on the bottom. The value is meant to be changed if one want keep the moving droplet in a small frame.
**/
  u.t[bottom] = dirichlet(-param.U);
  f[bottom]   = 1.;

  printf ("-----Start of the simulation-----\n");
  run();

  fclose (fp_stats);   fclose (fp_interf);
  fclose (fp_lsqcout); fclose(fp_results);
}
/**
The droplet is initialized as a sphere cut by the plane s.t. the contact angle is THETA_EQ. A thin film of thickness HSTAR is also added on the plane surface.
The mesh refinement is forced on the interface of the initial profile to ensure the highest resolution in this region before the simulation start.
 **/
#define circle(x,y,R) (sq(R) - sq(x) - sq(y))
#define droplet(x,y,R,theta0,hstar) (sq(R) - sq(x) - sq(y + R * cos(theta0) - hstar))

event init (i = 0)
{
  //Parameters for vanderwaals_no-pos.h
  f.theta = param.THETA_EQ, f.hs = param.HSTAR, f.m = 3., f.k = 2.;
  if(param.VDW == 1 )
    sprintf (f.walls[0], "bottom");
  
  refine (level < param.MAX_LEVEL &&
	  (circle(x-param.XO, y-param.HSTAR,param.SIZE/(1 << (level+1)) + param.R0) >= 0
	      ||
	     y - param.SIZE/(1 << level) <= 0)
	  );
  fraction (f,max(droplet(x-param.XO, y,param.R0,param.THETA0,
			  param.HSTAR),param.HSTAR - y));
}

/**
Measurements on the system are made thirty times per seconds. 
It includes the different contact angles computation (left/right/all), averaged and maximum velocities, inflexion points, center of mass and total volume. 
Most of the function called are defined in contact_angle.h which contains the LSQC method and some auxiliary functions.
Some quantities are also kept between two measurement to compute quick differential calculus. 
They could also be used to detect a convergence.
 **/
event measurements (t += 1./30)
{
  //Update t_n variables
  tn = t;
  foreach(){
    uxf[] = u.x[] * f[];
    xf[] = x * f[];
    yf[] = y * f[];
  }
  Ucm = statsf(uxf).sum/statsf(f).sum;
  Xcm = statsf(xf).sum/statsf(f).sum;
  Ycm = statsf(yf).sum/statsf(f).sum;
  Inflexion_points (f, &XinfL, &XinfR);
  
  ca_mean = compute_contact_angle (f, &LSQC_x, &LSQC_y,&LSQC_R,
  					 XinfL, XinfR, 0.0);
  //					 0.0, param.SIZE, 0.2);
  ca_L = compute_contact_angle (f, &LSQC_xL, &LSQC_yL, &LSQC_RL,
   			        XinfL, Xcm, 0.0);
  //				0.0, Xcm, 0.2);
  ca_R = compute_contact_angle (f, &LSQC_xR, &LSQC_yR, &LSQC_RR,
				Xcm, XinfR, 0.0);
  //                            Xcm, param.SIZE, 0.2);
  umax  = statsf (u.x).max;
  umean = normf  (u.x).avg;
  vmax  = statsf (u.y).max;
  vmean = normf  (u.y).avg; 
  vol   = statsf (f).sum;

  //Compute derivative statistics
  VinfL   = derivative (XinfL_old, XinfL,  tnm1, tn);
  VinfR   = derivative (XinfR_old, XinfR,  tnm1, tn);
  LSQC_VR = derivative (LSQC_Rold, LSQC_R, tnm1, tn); 

  //Set t_{n-1} variables
  tnm1      = tn;
  XinfL_old = XinfL;
  XinfR_old = XinfR;
  LSQC_Rold = LSQC_R;
  theta_old = ca_mean;
  umax_old  = umax;
  umean_old = umean;
  vmax_old  = vmax;
  vmean_old = vmean;
  vol_old   = vol;

  //Writing statistics in stats.dat file
  fprintf (fp_stats,
	   "%-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g %-12g\n",
	   t,umax,umean,vmax,vmean,vol,ca_mean,LSQC_x,LSQC_y,
	   LSQC_R, LSQC_VR ,XinfL,XinfR, VinfL, VinfR, Xcm, Ycm, Ucm,
	   ca_L, ca_R);
  /**
Movie
  **/
  if (param.MOVIE != 0)
  {
    foreach()
      l[] = level;
    view (fov = 40, tx = -0.5);
    clear();
    draw_vof ("f", lw = 2.);
    squares ("p", linear = true);
    box (notics = true);
    mirror ({-1})
      {
	draw_vof ("f", lw = 2);
	squares ("l", linear = true);
	box (notics = true);
      }
    save (param.fn_movie);
  }
  //Additional stopping criterium
  if (Xcm >= param.SIZE - 1.5*param.R0)
  {
    fprintf (stderr,"\n\n!!Stopping criterium !!\n\n");
    //Drawing the final LSQCs
    fprintf (fp_lsqcout,"xinterf\t yinterf\t curv\n");
    draw_interface (f, fp_lsqcout);
    draw_LSQC (f, ca_mean, LSQC_x,  LSQC_y,
	     LSQC_R, 0.0, param.SIZE, fp_lsqcout);
    draw_LSQC (f, ca_L, LSQC_xL, LSQC_yL,
	     LSQC_RL, XinfL, Xcm, fp_lsqcout);
    draw_LSQC (f, ca_R, LSQC_xR, LSQC_yR,
	     LSQC_RR, Xcm, XinfR, fp_lsqcout);  
  
  //Writing Level and main results in the metadata file
    fprintf (fp_results, "%d\t %g\t %g\t %g\t %g\t %g\t %g\t %g\t %g\t %g\n",
	     param.LEVEL,param.THETA0/RADEG, param.THETA_EQ/RADEG, param.HSTAR,
	   ca_mean, param.SIZE, param.PANGLE, ca_L, ca_R, umean);
  
  dump (file = param.fn_dump);
  return 1;
  }
}

event terminalinfo (i++)
{
  fprintf (stderr,"i = %d (%.0f %%) \t t = %.4g\r",i,(t*100.0/param.TMAX) ,t);
}

event end (t = param.TMAX)
{
  //Drawing the final LSQCs
  fprintf (fp_lsqcout,"xinterf\t yinterf\t curv\n");
  draw_interface (f, fp_lsqcout);
  
  draw_LSQC (f, ca_mean, LSQC_x,  LSQC_y,
	     LSQC_R, 0.0, param.SIZE, fp_lsqcout);
  
  draw_LSQC (f, ca_L, LSQC_xL, LSQC_yL,
	     LSQC_RL, XinfL, Xcm, fp_lsqcout);
  
  draw_LSQC (f, ca_R, LSQC_xR, LSQC_yR,
	     LSQC_RR, Xcm, XinfR, fp_lsqcout);
  
  //Writing Level and main results in the metadata file
  fprintf (fp_results, "%d\t %g\t %g\t %g\t %g\t %g\t %g\t %g\t %g\t %g\n",
	   param.LEVEL,param.THETA0/RADEG, param.THETA_EQ/RADEG, param.HSTAR,
	   ca_mean, param.SIZE, param.PANGLE, ca_L, ca_R, umean);
  
  dump (file = param.fn_dump);
}

