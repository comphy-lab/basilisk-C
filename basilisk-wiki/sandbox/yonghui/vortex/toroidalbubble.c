/**
##  Generation of Toroidal Bubble
For a toroidal bubble at rest, the bubble cannot keep its size for 2 reasons: the instability of Plateau-Rayleigh which breaks the bubble into several small bubbles and the surface tension which entails the bubble in a spherical shape.

In reality a toroidal bubble can be generated by 
[humans](https://youtu.be/vFbN31EuMvc) 
or
[dolphins](https://youtu.be/bT-fctr32pE) and last a long time.
We are curious about the generation and evolution of this phenomenes.

In another [code](http://basilisk.fr/sandbox/yonghui/vortex/swirlaj.c),
we showed that the swirling dynamics around the bubble will stabilize it and avoid R-P instability occurs.

In this code, we are mainly interested in the generation of the toroidal bubble and its evolution with different parameters ($Re,We,Wb$),
we assume that it is axisymmetric with the initial configuration as follows:


![Two phase flow setup](toroidalbubble/finit.png)


In some cases, the exit vortex stretches the bubble into a toroidal shape and reaches equilibrium with surface tension.
*/
#include "axi.h"  
#include "navier-stokes/centered.h"
#include "two-phase.h"
#include "tension.h"
#include "tag.h"  
#include "view.h"
/**
Parameters
*/
#define LVM 10         // max refine level 
#define thick 0.015625 //
#define R0 0.125       // solid nozzle's inner layer radius
#define Re 5000.       // Dimensionless Re = Re_sim * R_0
#define We 100.        // Dimensionless We = We_sim * R_0
#define mur 0.02       //ratio viscosity water-air
#define tramp 0.1*R0   //start time 
#define deltag sqrt(R0/Re)*R0 //vorticity layer thickness based on Re
#define ainj 4.6*R0    // x position of bubble's right interface 
#define xinj 4.8*R0    // x position of nozzle's right interface 
// Wb: initial bubble size, take a try with 0.6, 1.2, 2.4, 4, etc) 
#define Wb 4.*R0  
#define tend 3.0  
//
FILE * fp1, * fp2, * fp3;
scalar omega[];
/**
## Boundary Conditions
We use a free outflow condition at right-hand-side and a non-penetration condition at top.

At left-hand-side, the outter part of the nozzel ($r > R_0$) is set to a wall condition while the inner part ($r \leq R_0$) has normalized inflow velocity under the form :
$$
u_{x}(x=0, r, t) = \operatorname{erf}(t / \tau) \operatorname{erf}(\frac{R_0-r}{\delta}  ), 
\quad u_{r}=0 
\quad \text { with } \quad
\delta= R_0 \sqrt{R_0 t /Re} 
$$
where $\tau$ is the tramp time and $\delta$ the vorticity layer thickness.

The nozzle(solid) is set to a no-slip wall condition.
*/
u.n[top] = dirichlet(0.0);
u.n[right] = neumann(0.0);
p[right]   = dirichlet(0.0);

u.n[left] = y <= R0 ? dirichlet(erf(t/tramp)*erf((-y+R0)/(deltag * sqrt(t/R0 + 1.e-6) ) )) : dirichlet(0.0);
u.t[left] = dirichlet(0.);
f[left] = dirichlet(0.);

bid solid;
u.n[solid] = dirichlet(0.0);
u.t[solid] = dirichlet(0.0);
/**
## main 
The length is normalized with $L_c = 8 R_0 $, while the size can be changed based on time and bubble size.
The phase 1 is the air bubble and phase 2 the water.
We set
$\mu_r = \frac{\mu_{air} }{ \mu_{water} } = 0.02$ and 
$\rho_r = \frac{\rho_{air} }{ \rho_{water} } = 0.001$ .

A small tolerance $10^{-5}$ is needed with the complexe solid-water-air trible phase (we use the mask function as the embed is still not coworked with surface tension, which shoule  easier the simulation if works).
*/
int main() {
  size(2.);
  init_grid (64);
  //origin(-1./2.,0);
  rho1 = 1.e-3, mu1 = mur*R0/Re;
  rho2 = 1., mu2 = R0/Re, f.sigma = R0/We;
  TOLERANCE = 1e-5;
  //DT = 0.001;
  fp1 = fopen("stat_bub","w");
  fp2 = fopen("vort_bub","w");
  fp3 = fopen("bub3","w");
  run();
}
/**
## init
We refined the part $r < 3 R_0$ where the majority dynamics occurs (LVM $\geq 9$ for size 1 is almost necessary). 

Then we use the mask function to define the solid interface and call the initial bubble at $r \leq R_0,\quad  a_{inj}- W_b \leq x \leq a_{inj}$, the bubble is attached to the nozzle's inner surface!


*/

event init (t = 0) {
  refine ( y < R0 * 2.6  && level < LVM);
  mask ( (x < xinj && y > R0 && y + 0.5*x< R0 + 0.5*xinj && y < R0 + 2.*thick) ? solid :none);

  fraction (f, (x < ainj && x > ainj - Wb && y < R0*1.01) ? 1 : 0  );

  char legensd[2000]; //time
  sprintf(legensd, " rb = %g, Re = %g, We = %g., t=%0.2g", Wb*8, Re, We,t);
  // ============ whole domain view=================
  // view (fov = 24.,tx = -0.5, ty = -0.5, bg = {1,1,1}, width = 1024, height = 1024, samples = 1);
  // ============ very close view to the nozzle=====
  // view (fov = 4.,tx = -0.1, ty = 0.01, bg = {1,1,1}, width = 2048, height = 2048, samples = 1);
  // ============ close view to the nozzle =========
  //view (fov = 5.,tx = -0.2, bg = {1,1,1}, width = 2000, height = 1250, samples = 1);
  // ============ personal best choice =============
  view (fov = 6.,tx = -0.5,  bg = {1,1,1}, width = 2048, height = 600, samples = 1);
  clear();
  squares("f",max=1.,min=0.);
  mirror (n = {0., 1.}, alpha = 0.) {
    draw_vof("f", lw = 4);
    draw_string(legensd, 0, size = 60.,lw = 5.);
    cells();
  }
  save ("fnint.png");
}


event mydata (i++; t <= tend){
  fprintf (stderr, "%d %d %d %g %g %g\n", \
           i, mgp.i, mgu.i, t, dt, statsf(f).sum);
}

/**
Here with ELIMINATE, we can remove the small "size" (actually surface) toroidal bubbles or drops which will occur for a small We number or at the detachment.
We use the [tag](http://basilisk.fr/src/tag.h#tag) function, and some ideas from [lopez](http://basilisk.fr/sandbox/lopez/droplet_stat.h).
*/
#if 1 //ELIMINATE_AIR
event bubblecount( i += 20){
  scalar m[];
  foreach(){
    m[] = f[] > 1e-4;}
  int n = tag (m);
  double v[n];     //volume /(2 PI) !!!!!
  double sft[n];   //surface
  double cnc[n];   //cell number count
  coord b[n];
  for (int j = 0; j < n; j++){
    v[j] = b[j].x = b[j].y =  sft[j]= cnc[j] = 0.;
  }

  foreach_leaf(){
    if (m[] > 0) {
      int j = m[] - 1;
      v[j] += dv()*f[];
      sft[j] += sq(Delta)*f[];
      cnc[j] += f[];
      coord p = {x,y,z};
      foreach_dimension()
        b[j].x += dv()*f[]*p.x;
    }
  }
  // less than $5 \%$ initial surface
  double sfmax = 0.05*R0*Wb;		


  for (int j = 0; j < n; j++) {
    fprintf (fp1, "%d %g %d %g %g %g %g\n", i, t, j, v[j],sft[j], b[j].x,b[j].y );

    fflush (fp1);  

    double cellv=0.;
    foreach(){ 
      if (m[] > 0) {
        int j = m[]-1;
        if(sft[j] < sfmax){
          f[] = 0.;
          fprintf (stdout, "## CLEAN %d %g %g %g %g %g\n", i, t, x, y, sft[j], cnc[j]);
          cellv += f[]*sq(Delta);
        }
      }
    }
    fflush (stdout);  
  }

}
#endif

#if 1 //ELIMINATE_WATER
event dropcount( i += 20){
  scalar mm[];
  foreach(){
    mm[] = f[] < 0.99;}
  int n = tag (mm);
  double wsft[n]; //surface
  coord b[n];
  for (int j = 0; j < n; j++){
    b[j].x = b[j].y =  wsft[j] = 0.;
  }

  foreach_leaf(){
    if (mm[] > 0) {
      int j = mm[] - 1;
      wsft[j] += sq(Delta)*(1.-f[]);
      coord p = {x,y,z};
      foreach_dimension()
        b[j].x += dv()*(1.-f[])*p.x;
    }
  }
  // less than $5 \%$ initial surface
  double sfmax = 0.05*R0*Wb;		

  foreach(){ 
    if (mm[] > 0) {
      int j = mm[]-1;
      if(wsft[j] < sfmax){
        f[] = 1.;
      }
    }
  }
  fflush (stdout);  
}
#endif

/**
!!!! ATTENTION : this event is not compatible with openMP !!!!

In this event, we calculate the mean vorticity inside the bubble (A better version can be done with selection of the biggest bubble, as sometimes the main bubble will break into 2 parts ($We=20,Wb=4 R_0$)).

We calculate the mean radius and mean vorticity with equation: 
$$
a_{\mathrm{B}}=\sqrt{\frac{I_{1}}{\pi}} R_{0} \quad \text { and } \quad \Gamma_{\mathrm{B}}=I_{2} U_{0} R_{0}, \quad \text { with } \quad I_{1}=\int_{S} \mathrm{d} x \mathrm{d} r, \quad I_{2}=\int_{S} \omega \mathrm{d} x \mathrm{d} r
$$

The results noted $(B)$ is linked to the paramaters used in another [code](http://basilisk.fr/sandbox/yonghui/vortex/swirlaj.c) noted $(A)$ via:
$$
Re_{B} \sqrt{ \frac{a_B}{ L_c We_B} } = Re_A
, \quad 
 \sqrt{We_B a_B^3} \omega_B = \frac{\omega_A}{2} = \bar{q}_A 
$$
*/

event meanvort (t += 0.01){
  vorticity (u, omega);
  double II1 = 0.;
  double II2 = 0.;

  foreach(){
    II1 += omega[]*sq(Delta)*f[];
    II2 += sq(Delta)*f[];
  }

  if (II2 > 1e-3){
    double vort = II1/(II2*R0);	
    double aa0 = sqrt(II2/M_PI);
    double qq = sqrt(We*pow(aa0,3))*II1/(II2*R0);
    fprintf (fp2, "%g %g %g %g %g %g\n",  t, II1,II2,vort,aa0,qq);
  }
  fflush (fp2);  
}

/**
In this event, we ouput the vorticity profiles as a function of $r$ and $x$ with origin centered to the biggest bubble (a view as 2D). */
event profile_vorticity (t += 0.1){
  if (t>1.){
    scalar m[];
    foreach(){
      m[] = f[] > 1e-4;}
    int n = tag (m);
    double sft[n]; //surface
    coord b[n];
    for (int j = 0; j < n; j++){
      b[j].x = b[j].y =sft[j]= 0.;
    }

    foreach_leaf(){
      if (m[] > 0) {
        int j = m[] - 1;
        sft[j] += sq(Delta)*f[];
        coord p = {x,y,z};
        foreach_dimension()
          b[j].x += sq(Delta)*f[]*p.x;
      }
    }

    int nmax=0;
    if (n > 0){
      for (int j = 0; j < n; j++){
        nmax = sft[nmax] <= sft[j] ? j : nmax;
      }}

    double bubcx= b[nmax].x/sft[nmax];
    double bubcy= b[nmax].y/sft[nmax];
    fprintf (fp3, "%d %g %g %g \n", i, t, bubcx,bubcy);
    fflush (fp3);  


    char vorlogx[2000]; //time
    sprintf(vorlogx, "vorx_t%03g", t*100);
    FILE * fpf = fopen (vorlogx, "w");
    char vorlogy[2000]; //time
    sprintf(vorlogy, "vory_t%03g", t*100);
    FILE * fpf2 = fopen (vorlogy, "w");

    for(double xx =bubcx-0.1; xx<bubcx+0.1; xx += 0.0025){
      fprintf(fpf,"%g %g %g %g %g\n",t,xx-bubcx,bubcy,interpolate(omega,xx,bubcy),interpolate(f,xx,bubcy));
      fflush (fpf);  
    }

    for(double yy =bubcy-0.1; yy<bubcy+0.1; yy += 0.0025){
      fprintf(fpf2,"%g %g %g %g %g\n",t,bubcx,yy-bubcy,interpolate(omega,bubcx,yy),interpolate(f,bubcx,yy));
      fflush (fpf2);  
    }
  }
}

/**
We can also output the video, it works with openMP.
*/
event video_for_fun (t = 0.; t <= tend; t += 0.01) {
  vorticity (u, omega);

  char legend[2000]; //time
  sprintf(legend, "r_b = %g R_0, Re = %g, We = %g., t=%0.2g", Wb*8, Re, We,t);

  view (fov = 6.,tx = -0.5, ty = 0.03, bg = {1,1,1}, width = 2048, height = 600, samples = 1);
  clear();
  squares("f",max=1.,min=0.);
  draw_string(legend, 0, size = 60.,lw = 5.);
  draw_vof("f", lw = 1.5);
  mirror (n = {0., 1.}, alpha = 0.) {
    squares("omega",max=30.,min=-30.);
    draw_vof("f", lw = 3.);
  }
  save ("bubbleform1.mp4");
}

#if 0 //output pictures
event vtketdump (t += 0.1){
  vorticity (u, omega);

  char picname[800];
  sprintf (picname, "Re%gWe%grb%02gt%03g.png",Re,We,Wb*800, t*100);
  view (fov = 6.,tx = -0.5, bg = {1,1,1}, width = 2048, height = 600, samples = 1);
  clear();
  squares("f",max=1.,min=0.);
  draw_vof("f", lw = 1.5);
  mirror (n = {0., 1.}, alpha = 0.) {
    squares("omega",max=30.,min=-30.);
    draw_vof("f", lw = 3.);
  }
  save (picname);
}
#endif

/**
# Results
![Bubbble's evolution](toroidalbubble/bubbleform1.mp4)(loop)
*/








