/**
# Atomisation of a liquid jet onto a cylinder surface. No-wetting and perfect wetting solids.

A dense cylindrical liquid jet is injected into a stagnant lighter
phase (density ratio 1/27.84) with a cylinder solid obstacle. Wetting properties are set in the initial condition. Surface tension is included and ultimately controls the
characteristic scale of the smallest droplets.

We solve the two-phase Navier--Stokes equations with surface
tension.

 Brinkman Penalization method ([BPM](http://basilisk.fr/sandbox/weugene/penalization.h)) is used to handle solids. To switch on BPM, BRINKMAN_PENALIZATION is defined,
 to see/output debug fields (penalization term - dbp, total right-hand-side - total_rhs,
 tangential (along the solid surface) component of the velocity - utau (NEED CALCULATION of the normal to the solid surface n_sol),
 grad_utau_n(NEED n_sol)), DEBUG_BRINKMAN_PENALIZATION is defined.

 Default solid velocity target_U is equal to 0.
 Penalization coefficient eta_s = 1e-15.
 fs is a mask field: 1 inside solid, 0 outside.

 */
#define BRINKMAN_PENALIZATION 1
#define DEBUG_BRINKMAN_PENALIZATION 1
#include "centered-weugene.h"
#include "two-phase.h"
#include "tension.h"
#include "tag.h"
#include "view.h"
#include "output_vtu_foreach.h"

/**
We define the radius of the jet, the initial jet length, the Reynolds
number and the surface tension coefficient. */

#define radius 1./12.
#define Rsolid 1
#define length 0.025
#define Re 5800
#define SIGMA 1e-4
/**
The default maximum level of refinement is 10 and the error threshold
on velocity is 0.1. */

int minlevel = 5;
int maxlevel = 10;
double uemax = 0.1;
static int iteration=0;
/**
To impose boundary conditions on a disk we use an auxilliary volume
fraction field *f* which is one inside the cylinder and zero
outside. We then set an inflow velocity on the
left-hand-side and free outflow on the right-hand-side. */

scalar f0[], fs[], omega[];
u.n[left]  = dirichlet(f0[]);
u.t[left]  = dirichlet(0);
#if dimension > 2
u.r[left]  = dirichlet(0);
#endif
p[left]    = neumann(0);
f[left]    = f0[];

u.n[right] = neumann(0);
u.t[right] = neumann(0);
p[right]   = dirichlet(0);

u.n[bottom] = neumann(0);
u.t[bottom] = neumann(0);
p[bottom]   = neumann(0);

u.n[top] = neumann(0);
u.t[top] = neumann(0);
p[top]   = neumann(0);
/**
The program can take two optional command-line arguments: the maximum
level and the error threshold on velocity. */

int main (int argc, char * argv[])
{
    if (argc > 1) maxlevel = atoi (argv[1]);
    if (argc > 2) uemax = atof (argv[2]);

    /**
    The initial domain is discretised with $64^3$ grid points. We set
    the origin and domain size. */
    eta_s = 1e-15;
    init_grid (64);
    origin (0, -1.5, -1.5);
    size (3.);

    /**
    We set the density and viscosity of each phase as well as the
    surface tension coefficient and start the simulation. */

    rho1 = 1., rho2 = 1./27.84;
    mu1 = 2.*radius/Re*rho1, mu2 = 2.*radius/Re*rho2;
    f.sigma = SIGMA;
    f0.refine = f0.prolongation = fraction_refine;
    run();
}

/**
## Initial conditions */

event init (t = 0) {

  if (!restore (file = "restart")) {

    /**
    We use a static refinement down to *maxlevel* in a cylinder 1.2
    times longer than the initial jet and twice the radius.
    We initialise the auxilliary volume fraction field for a cylinder of
    constant radius. */
    
    /**
    We then use this to define the initial jet and its velocity. */
    int it = 0;
    do {
        fraction (f0, sq(radius) - sq(y) - sq(z));
        foreach() {
            fs[] = sq(x - L0/2) + sq(y) < sq(Rsolid) ? 1 : 0;
            f[] = f0[]*(x < length);//no-wetting case
            //f[] = f0[]*(x < length) + fs[];//perfect wetting case
            u.x[] = f[];
        }
        boundary ({f,u.x});
    }while (adapt_wavelet({f, fs}, (double []){0.001, 0.001}, maxlevel=maxlevel, minlevel=minlevel).nf != 0 && ++it <= 10);
  }
}

/**
## Outputs

We log some statistics on the solver. */

event logfile (i++) {
  if (i == 0)
    fprintf (ferr,
	     "t dt mgp.i mgpf.i mgu.i grid->tn perf.t perf.speed\n");
  fprintf (ferr, "%g %g %d %d %d %ld %g %g\n", 
	   t, dt, mgp.i, mgpf.i, mgu.i,
	   grid->tn, perf.t, perf.speed);
}
/**
We save snapshots of the simulation at regular intervals to
restart or to post-process with [bview](/src/bview). */

event snapshot (t = 0.1; t += 0.1; t <= 10.8) {
  char name[80];
  sprintf (name, "snapshot-%g", t);
  scalar pid[];
  foreach()
    pid[] = fmod(pid()*(npe() + 37), npe());
  boundary ({pid});
  dump (name);
}

/**
## Counting droplets

The number and sizes of droplets generated by the atomising jet is a
useful statistics for atomisation problems. This is not a quantity
which is trivial to compute. The *tag()* function is designed to solve
this problem. Any connected region for which *f[] > 1e-3* (i.e. a
droplet) will be identified by a unique "tag" value between 0 and
*n-1*. */

event droplets (t += 0.1)
{
  scalar m[];
  foreach()
    m[] = f[] > 1e-3;
  int n = tag (m);

  /**
  Once each cell is tagged with a unique droplet index, we can easily
  compute the volume *v* and position *b* of each droplet. Note that
  we use *foreach_leaf()* rather than *foreach()* to avoid doing a
  parallel traversal when using OpenMP. This is because we don't have
  reduction operations for the *v* and *b* arrays (yet). */

  double v[n];
  coord b[n];
  for (int j = 0; j < n; j++)
    v[j] = b[j].x = b[j].y = b[j].z = 0.;
  foreach_leaf()
    if (m[] > 0) {
      int j = m[] - 1;
      v[j] += dv()*f[];
      coord p = {x,y,z};
      foreach_dimension()
	b[j].x += dv()*f[]*p.x;
    }

 /**
 When using MPI we need to perform a global reduction to get the
 volumes and positions of droplets which span multiple processes. */

#if _MPI
  MPI_Allreduce (MPI_IN_PLACE, v, n, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
  MPI_Allreduce (MPI_IN_PLACE, b, 3*n, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
#endif

  /**
  Finally we output the volume and position of each droplet to
  standard output. */

  for (int j = 0; j < n; j++)
    fprintf (fout, "%d %g %d %g %g %g\n", i, t,
	     j, v[j], b[j].x/v[j], b[j].y/v[j]);
  fflush (fout);
}
  
/**
## Mesh adaptation

We adapt the mesh according to the error on the volume fraction fields of liquid and solid f, fs
and the velocity $\mathbf{u}$. */

event adapt (i++) {
  adapt_wavelet ({f, fs, u}, (double[]){0.01, 0.01, uemax, uemax, uemax}, maxlevel=maxlevel, minlevel=minlevel);
}

//Output
event vtk_file (t += 0.01){
    char subname[80]; sprintf(subname, "atom");
    scalar l[];
    vorticity (u, omega);
    foreach() {l[] = level; omega[] *= 1 - fs[];}
    output_vtu_MPI( (scalar *) {f, fs, rhov, omega, p, l}, (vector *) {u}, subname, 0);
}

/**
## Results
It is seen that

- there is no penetration of liquid into the solid,

- velocity is equal 0 in solids

- indeed, the liquid has higher separation angle for a solid with perfect wetting, rather than surface no-wetting surface 


## No-wetting solid
[![](http://img.youtube.com/vi/GV3dDXy6xOo/maxresdefault.jpg){ width=49% }](http://www.youtube.com/watch?v=GV3dDXy6xOo "Volume fraction")
[![](http://img.youtube.com/vi/a-u8qcmy4tQ/maxresdefault.jpg){ width=49% }](http://www.youtube.com/watch?v=a-u8qcmy4tQ "Magnitute of the velocity")


## Perfect wetting 
[![](http://img.youtube.com/vi/DNpA79ypvf4/maxresdefault.jpg){ width=49% }](http://www.youtube.com/watch?v=DNpA79ypvf4 "Volume fraction")
[![](http://img.youtube.com/vi/cHyh93pDHMo/maxresdefault.jpg){ width=49% }](http://www.youtube.com/watch?v=cHyh93pDHMo "Magnitute of the velocity")

## See also

* [Similar example of the jet atomization](http://basilisk.fr/src/examples/atomisation.c)
*/
