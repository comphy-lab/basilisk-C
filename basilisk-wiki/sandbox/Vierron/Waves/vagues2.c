/**
## Surface wave generated by a submerged obstacle
*/
#include "embed.h"
#include "navier-stokes/centered.h"
#include "two-phase.h"
#include "reduced.h"
#include "navier-stokes/perfs.h"
#include "view.h"
#include "curvature.h"

int MAXLEVEL = 7;
int MINLEVEL = 4;
double Re, Fr, RHO = 1000.;
double U0= 1.;
double Heau = 0.9, xo=8.;
double EndTime = 41.;  
  
/**
The profile of the bump is calculated with a Gaussian centred in xo
*/
#define bump ((1./(1.*sqrt(2*M_PI)))*exp(-0.5*sq((x-xo)/1.)) - y)

int main() {
	L0 = 40.;
        Re = 1e3, Fr = 0.4;
	Y0 = -16;
	init_grid (1 << MAXLEVEL); 
	rho2=1000/RHO, mu2=1./Re;
	rho1=1/RHO, mu1=mu2*10.;
	G.y = - 1/sq(Fr);
  	Z.y = Heau;
	run();
}

/**
## Boundary Conditions
*/
/**
Our numerical experiment we use no-slip condition at the bottom and neumann at the right. Then we use a straight velocity profile at the inlet.
*/
u.n[left] = dirichlet(U0);
p[left] = neumann(0);
pf[left] = neumann(0);

#if 1
u.n[right] = neumann(0.);
p[right]   = dirichlet(0.);
pf[right]  = dirichlet(0.);
#endif

//u.n[bottom] = dirichlet(0.);
u.t[bottom] = dirichlet(0.);

/**
Embedded boundary Conditions
*/
#if 1
u.n[embed] = dirichlet(0.);
u.t[embed] = dirichlet(0.);
#endif
/**
## Initial conditions
*/
/**
A zero-velocity field is initialized with a water level of Heau. Then a bump at the bottom of the water.
*/
event init (t = 0){
	foreach(){
  		foreach_dimension()
			u.x[] = 0.;
  	}
  	fraction(f, (y - Heau));
        boundary({f,u});
    	vertex scalar phi[];
  	foreach_vertex(){
    		phi[] = -bump;
	}
  	boundary ({phi});
  	fractions (phi, cs, fs);
	dump();
}

/**
## Mesh adaptation
*/
/**
Each timestep, the grid is adapted with respect to the wavelet-based estimated discretization error for the representation of fraction field, the pressure field and the representation of the embedded boundary (cs)
*/
event adapt (i++){
	adapt_wavelet ((scalar*){f, cs, u},
		 (double[]){0.001, 0.001, 0.01, 0.01}, MAXLEVEL);
}
/**
## Outputs
*/
/**
We use output_facets to extract the coordinate (x,y) of the interface 
*/
event amplitude (t+= 0.5; t <= EndTime){
  	char names[80];
	sprintf(names, "interface%g", t);
	FILE * fout = fopen (names, "w");
	output_facets (f,fout);
	fclose(fout);
}

event extractPosition (i++) {
	vector h[];
	heights (f, h);
	double yMin = +HUGE;
	foreach(reduction(min:yMin)){
		if (h.y[] != nodata) {
			double yi = y + height(h.y[])*Delta;
			if (yi < yMin){
				yMin = yi;
			}
		}
	}
  	double yMax = -HUGE;
	foreach(reduction(max:yMax)){
		if (h.y[] != nodata) {
			double yi = y + height(h.y[])*Delta;
			if (yi > yMax){
				yMax = yi;
			}
		}
	}
	char name[80];
	sprintf(name, "data%g%g",Re,Fr);
	static FILE * fout = fopen (name, "w");
	fprintf(fout,"%g %g %g\n", t*U0/Heau, (yMax-yMin)/Heau, abs(G.y)*(yMax/Heau));
	fflush(fout);
}

/**
video interface water/air + u.y
*/
event bviewer (i++) {
	clear();
	//view (fov = 3.94733, quat = {0.00660511,-0.00548634,-0.00016395,0.999963}, tx = -0.517473, ty = -0.102907, bg = {1,1,1}, width = 1220, height = 190, samples = 1);
       view (fov = 6.59963, quat = {0,0,0,1}, tx = -0.489368, ty = -0.172937, bg = {1,1,1}, width = 1340, height = 450, samples = 1);

        box();
        draw_vof ("cs","fs", filled = -1);
        draw_vof ("f", lw = 2); 
	squares ("u.y", linear = true);
        char namess[80];
	sprintf(namess, "t*U0/Heau=%g, Re=%g, Fr=%g",t*U0/Heau,Re,Fr);
  	draw_string(namess,pos=1);
	save ("vawes.mp4");

	scalar l[];
	foreach()
		l[] = level;
	output_ppm (l, file = "grid.mp4", n=512, min=MINLEVEL, max=MAXLEVEL, box = {{X0,Y0},{L0,5.}});
}

/**
## Results
We calculate the evolution of the amplitude which corresponds according to James Lighthill F(ko)
~~~gnuplot
reset
set xlabel 'times t/(U0/Heau)'
set ylabel 'Amplitude/Heau'
set title 'Evolution peak to peak amplitude interface'
plot 'data10000.4' u 1:2 w l lw 2 t 'using outputfacets'
~~~

![fraction field.](vagues2/vawes.mp4)
![grid.](vagues2/grid.mp4)
## Reference
J. Lighthill. Waves in Fluids. Cambridge University Press, 1978.
*/